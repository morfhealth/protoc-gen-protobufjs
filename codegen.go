package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	importPathFlag              = StringSlice("import_path", []string{}, "A mapping of proto imports to TS imports, as `PROTO_PATH=TS_PATH` pairs (this flag can be specified more than once). If the proto does not end with '.proto' then these act as directory prefixes.")
	strictImportsFlag           = flag.Bool("strict_imports", false, "If set, all directly imported protos must have an -import_path specified. This prevents the plugin from \"guessing\" import paths based on the proto path. This is also useful when integrating with build systems where all direct dependencies must be explicitly specified.")
	importModuleSpecifierEnding = flag.String("import_module_specifier_ending", "", "Suffix to apply to generated import module specifiers. May need to be set to \".js\" in rare cases.")

	outFlag = flag.String("out", "", "Output file `path`. If this is set and multiple protos are provided as input, the generated code for all protos will be written to this file. Any '.ts' or '.js' extension will be ignored.")

	importPaths = map[string]string{}
)

func generateCode(req *pluginpb.CodeGeneratorRequest) (*pluginpb.CodeGeneratorResponse, error) {
	for _, p := range *importPathFlag {
		parts := strings.SplitN(p, "=", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid import_path %q: should be of the form `PROTO_PATH_PREFIX=TS_PATH_PREFIX`", p)
		}
		protoPath, tsPath := parts[0], parts[1]
		if !strings.HasSuffix(protoPath, "/") && !strings.HasSuffix(protoPath, ".proto") {
			protoPath += "/"
		}
		if !strings.HasSuffix(tsPath, "/") && !strings.HasSuffix(protoPath, ".proto") {
			tsPath += "/"
		}
		importPaths[protoPath] = tsPath
	}

	// Debug: print a minimal version of the incoming CodeGeneratorRequest.
	if os.Getenv("VERBOSE") == "1" {
		// Throw away all source code info other than comments & the fields they
		// apply to.
		for _, f := range req.GetProtoFile() {
			var nonEmptyLocations []*descriptorpb.SourceCodeInfo_Location
			for _, l := range f.GetSourceCodeInfo().GetLocation() {
				if l.GetLeadingComments() != "" {
					l.Span = nil // span is unused
					nonEmptyLocations = append(nonEmptyLocations, l)
				}
			}
			f.GetSourceCodeInfo().Location = nonEmptyLocations
		}
		jb, _ := protojson.MarshalOptions{Multiline: true}.Marshal(req)
		logf("CodeGeneratorRequest: %s\n", string(jb))
	}

	var features uint64
	features |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	res := &pluginpb.CodeGeneratorResponse{
		SupportedFeatures: &features,
	}

	idx := BuildIndex(req)
	// If --out is set, write all sources to a single file.
	if *outFlag != "" {
		c := newCodegen(idx, *outFlag, req.GetFileToGenerate()...)
		outs, err := c.Generate()
		if err != nil {
			return nil, err
		}
		res.File = append(res.File, outs...)
	} else {
		// Otherwise write each source named according to the .proto path
		for _, path := range req.GetFileToGenerate() {
			out := strings.TrimSuffix(path, ".proto")
			c := newCodegen(idx, out, path)
			outs, err := c.Generate()
			if err != nil {
				return nil, err
			}
			res.File = append(res.File, outs...)
		}
	}

	return res, nil
}

// Namespace represents a namespace tree to be generated.
type Namespace struct {
	Name     string
	Files    []*descriptorpb.FileDescriptorProto
	Children map[string]*Namespace
}

// Codegen generates code for a single proto file descriptor.
type Codegen struct {
	Index *Index

	// Generated TypeScript declarations (.d.ts content)
	d *TS
	// Generated JS implementation (.js content)
	j *TS

	// Paths to the top-level protos to be translated to TS.
	Paths []string
	// Out is the file being generated by this codegen.
	Out string

	// Map of input file path -> map of SourceCodeInfo_Location.path stringified
	// list repr like "[4 5 1 2 0 3]" -> SourceCodeInfo_Location.leading_comment
	Comments map[string]map[string]string

	// Map of symbol -> import path
	ImportedSymbols map[string]string
	// Map of import path -> symbol
	ImportedFiles map[string]string
}

func newCodegen(idx *Index, out string, paths ...string) *Codegen {
	// Map of file path -> serialized
	comments := map[string]map[string]string{}
	for _, path := range paths {
		comments[path] = map[string]string{}
		for _, l := range idx.Files[path].GetSourceCodeInfo().GetLocation() {
			if l.GetLeadingComments() == "" {
				continue
			}
			comments[path][fmt.Sprint(l.GetPath())] = l.GetLeadingComments()
		}
	}
	return &Codegen{
		d:               &TS{},
		j:               &TS{JS: true},
		Index:           idx,
		Paths:           paths,
		Out:             out,
		Comments:        comments,
		ImportedSymbols: map[string]string{},
		ImportedFiles:   map[string]string{},
	}
}

// Generate returns two files: a .js file with generated message, enum, and
// service classes, as well as a companion .d.ts file with TypeScript typings
// for the JS code.
func (c *Codegen) Generate() ([]*pluginpb.CodeGeneratorResponse_File, error) {
	j, d := c.j, c.d

	// Check that all dependencies are indexed, since we need to know how to
	// import their types.
	for _, path := range c.Paths {
		for _, d := range c.Index.Files[path].GetDependency() {
			if _, ok := c.Index.Files[d]; !ok {
				return nil, fmt.Errorf("missing dependency %q in code generation request", d)
			}
		}
	}

	var outs []*pluginpb.CodeGeneratorResponse_File

	d.DefaultImport("protobufjs/minimal", "* as $protobuf")

	j.DefaultImport("protobufjs/minimal", "* as $protobuf")
	j.L("// Common aliases")
	j.L("const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;")
	j.L("// Exported root namespace")
	j.L("const $root = {};")
	root := c.buildNamespaceTree()
	for _, name := range sortedKeys(root.Children) {
		c.generateNamespace(root.Children[name], name)
	}

	outNoExt := c.Out
	for _, ext := range []string{".js", ".ts", ".d.ts"} {
		outNoExt = strings.ReplaceAll(outNoExt, ext, "")
	}

	declarationName := outNoExt + ".d.ts"
	declarationContent := d.String()
	declaration := &pluginpb.CodeGeneratorResponse_File{
		Name:    &declarationName,
		Content: &declarationContent,
	}
	outs = append(outs, declaration)

	jsName := outNoExt + ".js"
	jsContent := j.String()
	js := &pluginpb.CodeGeneratorResponse_File{
		Name:    &jsName,
		Content: &jsContent,
	}
	outs = append(outs, js)

	return outs, nil
}

func (c *Codegen) buildNamespaceTree() *Namespace {
	root := &Namespace{Children: map[string]*Namespace{}}
	for _, path := range c.Paths {
		f := c.Index.Files[path]
		parts := strings.Split(f.GetPackage(), ".")
		ns := root
		for _, part := range parts {
			c := ns.Children[part]
			if c == nil {
				c = &Namespace{Name: part, Children: map[string]*Namespace{}}
				ns.Children[part] = c
			}
			ns = c
		}
		ns.Files = append(ns.Files, f)
	}
	return root
}

func (c *Codegen) generateNamespace(ns *Namespace, nsPath string) {
	j, d := c.j, c.d
	d.Lf("export namespace %s {", ns.Name)
	if strings.Contains(nsPath, ".") {
		j.Lf("%s.%s = (() => {", stringPart(nsPath, ".", -2), ns.Name)
	} else {
		j.Lf("$root.%s = (() => {", ns.Name)
	}
	j.Lf("const %s = {};", ns.Name)
	for _, f := range ns.Files {
		c.generate(f, []int32{}, nsPath, f.GetMessageType(), f.GetEnumType(), f.GetService())
	}
	for _, name := range sortedKeys(ns.Children) {
		c.generateNamespace(ns.Children[name], nsPath+"."+name)
	}
	d.L("}")
	j.Lf("return %s;", ns.Name)
	j.L("})();")
	if !strings.Contains(nsPath, ".") {
		j.Lf("export const %s = $root.%s;", ns.Name, ns.Name)
	}
}

func (c *Codegen) generate(file *descriptorpb.FileDescriptorProto, sourcePath []int32, ns string, messages []*descriptorpb.DescriptorProto, enums []*descriptorpb.EnumDescriptorProto, services []*descriptorpb.ServiceDescriptorProto) {
	j, d := c.j, c.d
	curNS := stringPart(ns, ".", -1)

	// Generate message type interfaces
	for messageIndex, messageType := range messages {
		messageFieldTag := fileDescriptorMessageTypeTagNumber
		if len(sourcePath) > 0 {
			messageFieldTag = descriptorNestedTypeTagNumber
		}
		messagePath := append(sourcePath, int32(messageFieldTag), int32(messageIndex))

		// Message interface type
		d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(messagePath)])
		d.Lf("export interface I%s {", messageType.GetName())
		for fieldIndex, field := range messageType.Field {
			fieldPath := append(messagePath, descriptorFieldTagNumber, int32(fieldIndex))

			d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(fieldPath)])
			d.Lf("%s?: %s;", field.GetJsonName(), c.typeAnnotation(field))
		}
		d.L("}")

		// Message class type + implementation
		d.Lf("export class %s implements I%s {", messageType.GetName(), messageType.GetName())
		j.Lf("%s.%s = (() => {", curNS, messageType.GetName())
		j.Lf("class %s {", messageType.GetName())
		// Declare fields (to implement interface)
		for _, field := range messageType.GetField() {
			d.Lf("%s: %s;", field.GetJsonName(), c.typeAnnotation(field))
		}

		// Oneof getters/setters
		var numOneofs int32
		for _, field := range messageType.GetField() {
			if field.OneofIndex != nil && field.GetOneofIndex()+1 > numOneofs {
				numOneofs = field.GetOneofIndex() + 1
			}
		}
		if numOneofs > 0 {
			oneofFieldNames := make([][]string, int(numOneofs))
			for _, field := range messageType.GetField() {
				// Don't generate oneof API for optionals. protoc treats optionals as
				// oneofs containing a single field, but this is just for backwards
				// compatibility with code generators that don't have proper support for
				// optionals. We properly support optionals by typing them as
				// "T | undefined | null"
				if field.GetProto3Optional() {
					continue
				}

				if field.OneofIndex != nil {
					i := *field.OneofIndex
					oneofFieldNames[i] = append(oneofFieldNames[i], field.GetJsonName())
				}
			}
			for i, decl := range messageType.GetOneofDecl() {
				fieldNames := oneofFieldNames[i]
				if len(fieldNames) == 0 {
					continue
				}

				fieldStrings := make([]string, 0, len(fieldNames))
				for _, f := range fieldNames {
					fieldStrings = append(fieldStrings, fmt.Sprintf(`"%s"`, f))
				}

				fieldNameType := strings.Join(fieldStrings, " | ")
				fieldNameArray := "[" + strings.Join(fieldStrings, ", ") + "]"

				// TODO: maybe more performant in some cases to only iterate over own
				// properties of `this`
				d.Lf("/**")
				d.Lf(" * Returns the `%s` oneof field name that is set,", oneofFieldName(decl))
				d.Lf(" * or undefined if none is set.")
				d.Lf(" */")
				d.Lf("get %s(): %s | undefined;", oneofFieldName(decl), fieldNameType)

				j.Lf("get %s() {", oneofFieldName(decl))
				j.Lf("for (const key of %s) {", fieldNameArray)
				j.L("if (this[key] !== null && this[key] !== undefined) return key;")
				j.L("}")
				j.L("}")

				d.Lf("/**")
				d.Lf(" * Sets which `%s` oneof field is set", oneofFieldName(decl))
				d.Lf(" * by deleting any other fields in the oneof that might be set.")
				d.Lf(" */")
				d.Lf("set %s(name: %s | undefined): void;", oneofFieldName(decl), fieldNameType)

				j.Lf("set %s(name) {", oneofFieldName(decl))
				j.Lf("for (const key of %s) {", fieldNameArray)
				j.L("if (key !== name) delete this[key];")
				j.L("}")
				j.L("}")
			}
		}

		// Constructor
		d.Lf("constructor(properties?: I%s): %s;", messageType.GetName(), messageType.GetName())
		j.Lf("constructor(properties) {")
		// All repeated fields and maps are initialized to empty
		for _, f := range messageType.GetField() {
			if c.isMapField(f) {
				j.Lf("this.%s = {};", f.GetJsonName())
				continue
			}
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf("this.%s = [];", f.GetJsonName())
				continue
			}
		}
		j.L("if (properties) {")
		j.Lf("for (let key of Object.keys(properties)) {")
		j.L("if (properties[key] != null) this[key] = properties[key];")
		j.L("}")
		j.L("}")
		j.L("}")

		// Message.create()
		d.Lf("static create(properties?: I%s): %s;", messageType.GetName(), messageType.GetName())
		j.L("static create(properties) {")
		j.Lf("return new %s(properties)", messageType.GetName())
		j.L("}")

		//
		// Encode method
		//

		d.Lf("static encode(message: I%s, writer?: $protobuf.Writer): $protobuf.Writer;", messageType.GetName())
		j.Lf("static encode(message, writer) {")
		j.L("if (!writer) writer = $Writer.create();")
		for _, f := range messageType.GetField() {
			// Map fields (encode as repeated map entry message)
			if c.isMapField(f) {
				j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("for (const key of Object.keys(message.%s)) {", f.GetJsonName())
				mapEntryType := c.Index.MessageTypes[f.GetTypeName()]
				// Map entries always exactly two fields: key, then value
				kf := mapEntryType.GetField()[0]
				vf := mapEntryType.GetField()[1]
				begin := fmt.Sprintf("writer.uint32(%d).fork()", f.GetNumber()<<3|lenWireType)
				encodeKey := fmt.Sprintf(".uint32(%d).%s(key)", kf.GetNumber()<<3|wireType(kf), encodeMethodName(kf))
				if vf.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					classReference := c.resolveTypeName(vf.GetTypeName(), "$root.")
					j.L(begin + encodeKey + ";")
					j.Lf("%s.encode(message.%s[key], writer.uint32(%d).fork()).ldelim().ldelim();", classReference, f.GetJsonName(), vf.GetNumber()<<3|wireType(vf))
				} else {
					encodeValue := fmt.Sprintf(".uint32(%d).%s(message.%s[key])", vf.GetNumber()<<3|wireType(vf), encodeMethodName(vf), f.GetJsonName())
					j.L(begin + encodeKey + encodeValue + ".ldelim();")
				}
				j.L("}")
				j.L("}")
				continue
			}

			// Packed repeated fields
			if isPackedField(f) {
				j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("writer.uint32(%d).fork();", f.GetNumber()<<3|lenWireType)
				j.Lf("for (const element of message.%s) {", f.GetJsonName())
				j.Lf("writer.%s(element)", encodeMethodName(f))
				j.Lf("}")
				j.L("writer.ldelim();")
				j.L("}")
				continue
			}

			// Non-packed repeated fields
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("for (const element of message.%s) {", f.GetJsonName())
				if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
					j.Lf("%s.encode(element, writer.uint32(%d).fork()).ldelim();", classReference, f.GetNumber()<<3|lenWireType)
				} else {
					j.Lf("writer.uint32(%d).%s(element);", f.GetNumber()<<3|wireType(f), encodeMethodName(f))
				}
				j.L("}")
				j.L("}")
				continue
			}

			// Non-repeated fields
			j.Lf(`if (message.%s != null && Object.hasOwnProperty.call(message, "%s")) {`, f.GetJsonName(), f.GetJsonName())
			if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				// TODO: handle groups
				classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
				j.Lf("%s.encode(message.%s, writer.uint32(%d).fork()).ldelim();", classReference, f.GetJsonName(), f.GetNumber()<<3|lenWireType)
			} else {
				j.Lf("writer.uint32(%d).%s(message.%s);", f.GetNumber()<<3|wireType(f), encodeMethodName(f), f.GetJsonName())
			}
			j.L("}")
			continue
		}
		j.L("return writer;")
		j.L("}") // encode

		//
		// Decode method
		//

		d.Lf("static decode(reader: $protobuf.Reader | Uint8Array, length?: number): %s;", messageType.GetName())
		j.Lf("static decode(reader, length) {")
		j.L("if (!(reader instanceof $Reader)) reader = $Reader.create(reader);")
		j.L("let end = length === undefined ? reader.len : reader.pos + length;")
		j.Lf("let message = new %s();", messageType.GetName())
		j.L("let key, value;")
		j.L("while (reader.pos < end) {")
		j.L("let tag = reader.uint32();")
		j.L("switch (tag >>> 3) {")
		for _, f := range messageType.GetField() {
			j.Lf("case %d: {", f.GetNumber())
			(func() {
				// Map fields
				if c.isMapField(f) {
					j.Lf("if (message.%s === $util.emptyObject) message.%s = {};", f.GetJsonName(), f.GetJsonName())
					j.L("let end2 = reader.uint32() + reader.pos;")
					entryType := c.Index.MessageTypes[f.GetTypeName()]
					kf := entryType.GetField()[0]
					vf := entryType.GetField()[1]
					j.Lf("key = %s;", c.defaultValueExpression(kf))
					j.Lf("value = %s;", c.defaultValueExpression(vf))
					j.L("while (reader.pos < end2) {")
					j.L("let tag2 = reader.uint32();")
					j.L("switch (tag2 >>> 3) {")

					j.L("case 1: {")
					j.Lf("key = reader.%s();", encodeMethodName(kf))
					j.L("break;")
					j.L("}")

					j.L("case 2: {")
					if vf.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
						classReference := c.resolveTypeName(vf.GetTypeName(), "$root.")
						j.Lf("value = %s.decode(reader, reader.uint32());", classReference)
					} else {
						j.Lf("value = reader.%s();", encodeMethodName(vf))
					}
					j.L("break;")
					j.L("}")

					j.L("}") // switch
					j.Lf("message.%s[key] = value;", f.GetJsonName())
					j.L("}") // while
					return
				}

				// Packable (always check for forward and backward compatibility)
				if isPackableField(f) {
					// Note: the ".length" condition makes sure we replace the
					// $util.emptyArray with a new mutable array
					j.Lf("if (!message.%s || !message.%s.length) {", f.GetJsonName(), f.GetJsonName())
					j.Lf("message.%s = [];", f.GetJsonName())
					j.L("}")
					j.Lf("if ((tag & %d) === %d) {", wireTypeMask, lenWireType)
					j.L("let end2 = reader.uint32() + reader.pos;")
					j.Lf("while (reader.pos < end2) message.%s.push(reader.%s());", f.GetJsonName(), encodeMethodName(f))
					j.L("} else {")
					j.Lf("message.%s.push(reader.%s());", f.GetJsonName(), encodeMethodName(f))
					j.L("}")
					return
				}

				// Non-packable repeated fields
				if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
					// Note: the ".length" condition makes sure we replace the
					// $util.emptyArray with a new mutable array
					j.Lf("if (!message.%s || !message.%s.length) {", f.GetJsonName(), f.GetJsonName())
					j.Lf("message.%s = [];", f.GetJsonName())
					j.L("}")
					if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
						classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
						j.Lf("message.%s.push(%s.decode(reader, reader.uint32()));", f.GetJsonName(), classReference)
					} else {
						j.Lf("message.%s.push(reader.%s());", f.GetJsonName(), encodeMethodName(f))
					}
					return
				}

				// Non-repeated fields
				if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					classReference := c.resolveTypeName(f.GetTypeName(), "$root.")
					j.Lf("message.%s = %s.decode(reader, reader.uint32());", f.GetJsonName(), classReference)
				} else {
					j.Lf("message.%s = reader.%s();", f.GetJsonName(), encodeMethodName(f))
				}
			})()
			j.L("break;")
			j.L("}")
		}
		j.L("default: {")
		j.Lf("reader.skipType(tag & %d);", wireTypeMask)
		j.L("break;")
		j.L("}")
		j.L("}") // switch
		j.L("}") // while
		j.L("return message;")
		j.L("}") // decode()

		//
		// fromObject method
		//
		d.Lf("static fromObject(object: Record<string, any>): %s;", messageType.GetName())
		j.L("static fromObject(object) {")
		j.Lf("if (object instanceof $root.%s.%s) {", ns, messageType.GetName())
		j.L("return object;")
		j.L("}")
		j.Lf("const message = new $root.%s.%s();", ns, messageType.GetName())
		for _, f := range messageType.GetField() {
			// Map fields
			if c.isMapField(f) {
				j.Lf("if (object.%s) {", f.GetJsonName())
				j.Lf(`if (typeof object.%s !== "object") {`, f.GetJsonName())
				j.Lf(`throw new TypeError(".%s.%s.%s: object expected, but got " + (typeof object.%s));`, ns, messageType.GetName(), f.GetJsonName(), f.GetJsonName())
				j.L("}")
				j.Lf("message.%s = {};", f.GetJsonName())
				j.Lf("for (let keys = Object.keys(object.%s), i = 0; i < keys.length; ++i) {", f.GetJsonName())
				src := fmt.Sprintf("object.%s[keys[i]]", f.GetJsonName())
				dest := fmt.Sprintf("message.%s[keys[i]]", f.GetJsonName())
				mapEntryType := c.Index.MessageTypes[f.GetTypeName()]
				vf := mapEntryType.GetField()[1]
				c.generateFromObjectConversionStatements(dest, src, vf, messageType, ns)
				j.Lf("}")
				j.L("}")
				continue
			}
			// Repeated fields
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf("if (object.%s) {", f.GetJsonName())
				j.Lf("if (!Array.isArray(object.%s)) {", f.GetJsonName())
				j.Lf(`throw new TypeError(".%s.%s.%s: array type expected, but got " + (typeof object.%s))`, ns, messageType.GetName(), f.GetJsonName(), f.GetJsonName())
				j.Lf("}")
				j.Lf("message.%s = new Array(object.%s.length);", f.GetJsonName(), f.GetJsonName())
				j.Lf("for (let i = 0; i < object.%s.length; ++i) {", f.GetJsonName())
				src := fmt.Sprintf("object.%s[i]", f.GetJsonName())
				dest := fmt.Sprintf("message.%s[i]", f.GetJsonName())
				c.generateFromObjectConversionStatements(dest, src, f, messageType, ns)
				j.Lf("}")
				j.Lf("}")
				continue
			}

			// Non-repeated fields
			j.Lf("if (object.%s != null) {", f.GetJsonName())
			src := fmt.Sprintf("object.%s", f.GetJsonName())
			dest := fmt.Sprintf("message.%s", f.GetJsonName())
			c.generateFromObjectConversionStatements(dest, src, f, messageType, ns)
			j.Lf("}")
		}
		j.L("return message;")
		j.L("}")

		//
		// toObject method
		//

		d.Lf("static toObject(message: %s, options: $protobuf.IConversionOptions): { [k: string]: any };", messageType.GetName())
		j.L("static toObject(message, options = {}) {")
		j.L("const object = {};")
		// Init arrays
		j.L("if (options.arrays || options.defaults) {")
		for _, f := range messageType.GetField() {
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED && !c.isMapField(f) {
				j.Lf("object.%s = [];", f.GetJsonName())
			}
		}
		j.L("}")
		// Init maps
		j.L("if (options.objects || options.defaults) {")
		for _, f := range messageType.GetField() {
			if c.isMapField(f) {
				j.Lf("object.%s = {};", f.GetJsonName())
			}
		}
		j.L("}")
		// Init default values
		j.L("if (options.defaults) {")
		for _, f := range messageType.GetField() {
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED || c.isMapField(f) || f.GetProto3Optional() || f.OneofIndex != nil {
				continue
			}
			if isLong(f.GetType()) {
				j.L("if ($util.Long) {")
				j.Lf("let long = new $util.Long(0, 0, %t)", isUint(f.GetType()))
				j.Lf(`object.%s = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;`, f.GetJsonName())
				j.L("} else {")
				j.Lf(`object.%s = options.longs === String ? "0" : 0;`, f.GetJsonName())
				j.L("}")
				continue
			}
			if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_BYTES {
				j.L("if (options.bytes === String) {")
				j.Lf(`object.%s = ""`, f.GetJsonName())
				j.L("} else {")
				j.Lf("object.%s = [];", f.GetJsonName())
				j.Lf("if (options.bytes !== Array) {")
				j.Lf("object.%s = $util.newBuffer(object.%s);", f.GetJsonName(), f.GetJsonName())
				j.L("}")
				j.L("}")
				continue
			}
			if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
				j.Lf(`object.%s = options.enums === String ? "%s" : 0`, f.GetJsonName(), c.enumZeroValue(f).GetName())
				continue
			}
			j.Lf("object.%s = %s;", f.GetJsonName(), c.defaultValueExpression(f))
		}
		j.L("}")
		// Convert message fields
		j.L("let keys;")
		for _, f := range messageType.GetField() {
			if c.isMapField(f) {
				mapEntryType := c.Index.MessageTypes[f.GetTypeName()]
				vf := mapEntryType.GetField()[1]
				j.Lf("if (message.%s && (keys = Object.keys(message.%s)).length) {", f.GetJsonName(), f.GetJsonName())
				j.Lf("object.%s = {};", f.GetJsonName())
				j.L("for (let i = 0; i < keys.length; ++i) {")
				j.Lf("object.%s[keys[i]] = %s;", f.GetJsonName(), c.toObjectConversionExpression(vf, "message."+f.GetJsonName()+"[keys[i]]"))
				j.L("}")
				j.L("}")
				continue
			}
			if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
				j.Lf(`if (message.%s && message.%s.length) {`, f.GetJsonName(), f.GetJsonName())
				j.Lf("object.%s = new Array(message.%s.length);", f.GetJsonName(), f.GetJsonName())
				j.Lf("for (let i = 0; i < message.%s.length; ++i) {", f.GetJsonName())
				j.Lf("object.%s[i] = %s;", f.GetJsonName(), c.toObjectConversionExpression(f, "message.%s[i]", f.GetJsonName()))
				j.Lf("}")
				j.Lf("}")
				continue
			}
			j.Lf(`if (message.%s != null && message.hasOwnProperty("%s")) {`, f.GetJsonName(), f.GetJsonName())
			j.Lf("object.%s = %s;", f.GetJsonName(), c.toObjectConversionExpression(f, "message.%s", f.GetJsonName()))
			if f.OneofIndex != nil && !f.GetProto3Optional() {
				j.L("if (options.oneofs) {")
				j.Lf(`object.%s = "%s";`, oneofFieldName(parentOneof(messageType, f)), f.GetJsonName())
				j.L("}")
			}
			j.L("}")
		}
		j.L("return object;")
		j.L("}")

		// toJSON
		// d.L("toJSON(): { [k: string]: any }")

		// getTypeUrl
		d.L(`static getTypeUrl(typeUrlPrefix = "type.googleapis.com"): string;`)
		j.L(`static getTypeUrl(typeUrlPrefix = "type.googleapis.com") {`)
		j.Lf(`return typeUrlPrefix + "%s.%s";`, ns, messageType.GetName())
		j.L("}")

		// End class definition
		d.L("}")
		j.L("}")

		// Define prototype methods (note: not the same as static methods)
		// j.Lf("%s.prototype.toJSON = function toJSON() {", messageType.GetName())
		// j.L("return this.constructor.toObject(this, $protobuf.util.toJSONOptions);")
		// j.L("}")

		// Assign defaults to class prototype instance
		for _, field := range messageType.GetField() {
			j.Lf("%s.prototype.%s = %s;", messageType.GetName(), field.GetJsonName(), c.defaultValueExpression(field))
		}

		// Generate sub-namespaces containing any nested messages and enums.
		// Don't generate map entry types explicitly since we generate native
		// map code instead.
		nestedMessageTypes := excludeMapEntries(messageType.GetNestedType())
		if len(nestedMessageTypes) > 0 || len(messageType.GetEnumType()) > 0 {
			d.Lf("export namespace %s {", messageType.GetName())
			c.generate(file, messagePath, ns+"."+messageType.GetName(), nestedMessageTypes, messageType.GetEnumType(), nil /*=services*/)
			d.L("}")
		}

		j.Lf("return %s;", messageType.GetName())
		j.L("})();")
	}

	// Generate enums
	for enumIndex, enumType := range enums {
		enumFieldTag := fileDescriptorEnumTypeTagNumber
		if len(sourcePath) > 0 {
			enumFieldTag = descriptorEnumTypeTagNumber
		}
		enumPath := append(sourcePath, enumFieldTag, int32(enumIndex))

		d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(enumPath)])
		d.Lf("export enum %s {", enumType.GetName())
		j.Lf("%s.%s = (function() {", curNS, enumType.GetName())
		j.Lf("const valuesById = {};")
		j.Lf("const values = Object.create(valuesById);")
		for valueIndex, value := range enumType.GetValue() {
			valuePath := append(enumPath, enumDescriptorValueTagNumber, int32(valueIndex))
			d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(valuePath)])
			d.Lf("%s = %d,", value.GetName(), value.GetNumber())
			j.Lf("values[valuesById[%d] = %q] = %d;", value.GetNumber(), value.GetName(), value.GetNumber())
		}
		d.L("}")
		j.Lf("return values;")
		j.L("})();")
	}

	// Generate services
	for serviceIndex, serviceType := range services {
		servicePath := append(sourcePath, fileDescriptorServiceTagNumber, int32(serviceIndex))
		d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(servicePath)])

		d.Lf("export interface I%s {", serviceType.GetName())
		for methodIndex, method := range serviceType.GetMethod() {
			methodPath := append(servicePath, serviceMethodTagNumber, int32(methodIndex))
			d.BlockComment(c.Comments[file.GetName()][fmt.Sprint(methodPath)])
			d.Lf(
				`%s: { readonly name: "%s" } & ((request: %s) => Promise<%s>);`,
				serviceMethodJSName(method), method.GetName(), interfaceTypeName(c.resolveTypeName(method.GetInputType(), "")), c.resolveTypeName(method.GetOutputType(), ""))
		}
		d.L("}")

		d.Lf("export class %s extends $protobuf.rpc.Service implements I%s {", serviceType.GetName(), serviceType.GetName())
		j.Lf("%s.%s = (() => {", curNS, serviceType.GetName())
		j.Lf("class %s extends $protobuf.rpc.Service {", serviceType.GetName())

		d.L("constructor(rpcImpl: $protobuf.RPCImpl, requestDelimited = false, responseDelimited = false);")
		j.L("constructor(rpcImpl, requestDelimited = false, responseDelimited = false) {")
		j.Lf("super(rpcImpl, requestDelimited, responseDelimited);")
		j.L("}")

		d.L("static create(rpcImpl: $protobuf.RPCImpl, requestDelimited = false, responseDelimited = false);")
		j.L("static create(rpcImpl, requestDelimited = false, responseDelimited = false) {")
		j.Lf("return new %s(rpcImpl, requestDelimited, responseDelimited);", serviceType.GetName())
		j.L("}")

		for _, method := range serviceType.GetMethod() {
			d.Lf(`%s!: I%s["%s"];`, serviceMethodJSName(method), serviceType.GetName(), serviceMethodJSName(method))
		}

		// End class definition
		d.L("}")
		j.L("}")

		// Define service methods on class prototype, including readonly "name" prop
		for _, method := range serviceType.GetMethod() {
			j.Lf(
				"Object.defineProperty(%s.prototype.%s = function %s(request, callback) {",
				serviceType.GetName(), serviceMethodJSName(method), serviceMethodJSName(method))
			j.Lf("return this.rpcCall(%s, %s, %s, request, callback);", serviceMethodJSName(method), c.resolveTypeName(method.GetInputType(), "$root."), c.resolveTypeName(method.GetOutputType(), "$root."))
			j.Lf(`}, "name", { value: "%s" });`, method.GetName())
		}

		j.Lf("return %s;", serviceType.GetName())
		j.L("})();")
	}
}

// resolveTypeName accepts a fully-qualified proto type name such as
// ".my.package.MyMessage.MyNestedEnum" and resolves it to a fully qualified
// TypeScript symbol.
//
// If the symbol exists in the local file, the given "localRootPrefix" is
// prepended instead of importing a file. The $root prefix is needed to ensure
// an absolute symbol reference, i.e. to avoid accidentally referencing a symbol
// in the current scope.
//
// The localRootPrefix should be set to "$root." and only when generating JS
// code, because TypeScript declarations do not need the "$root" prefix to
// figure out the right type.
// TODO: test this assumption - is this accurate?
func (c *Codegen) resolveTypeName(name string, localRootPrefix string) string {
	importFile := c.Index.Files[c.Index.FilesByType[name].GetName()]
	for _, path := range c.Paths {
		// Type will be generated in the current output file; no need to import.
		if path == importFile.GetName() {
			return localRootPrefix + name[1:]
		}
	}
	if importFile == nil {
		fatalf("could not resolve import for %s")
	}
	if _, ok := importPaths[importFile.GetName()]; !ok && *strictImportsFlag {
		fatalf("-strict_imports failure: missing %q in -import_path entries %s", importFile.GetName(), *importPathFlag)
	}

	// Import the type, possibly with aliasing.
	resolvedImportPath := strings.TrimSuffix(importFile.GetName(), ".proto")
	// logf("prefixed import path (before prefixing): %s", prefixedImportPath)
	for protoPath, tsPath := range importPaths {
		if protoPath == importFile.GetName() {
			resolvedImportPath = tsPath
			break
		}
		if strings.HasSuffix(protoPath, "/") && strings.HasPrefix(resolvedImportPath, protoPath) {
			resolvedImportPath = filepath.Join(tsPath, strings.TrimPrefix(resolvedImportPath, protoPath))
			// logf("prefixed import path for %s -> %s", importFile.GetName(), prefixedImportPath)
			break
		}
	}

	importRelPath, err := filepath.Rel(filepath.Join(".", filepath.Dir(c.Out)), filepath.Join(".", resolvedImportPath))
	if err != nil {
		fatalf("failed to compute relpath: %s", err)
	}
	if !strings.HasPrefix(importRelPath, ".") {
		importRelPath = "./" + importRelPath
	}
	alias := ""
	if c.ImportedSymbols[importRelPath] != "" {
		alias = c.ImportedSymbols[importRelPath]
	}

	importPkg := strings.Split(name, ".")[1]
	// To keep things simple for now, alias all imported symbols even if they
	// don't conflict with any symbols in the scopes where they are referenced.
	if alias == "" {
		i := 0
		for i == 0 || (c.ImportedFiles[alias] != "" && c.ImportedFiles[alias] != importRelPath) {
			i++
			alias = fmt.Sprintf("%s$%d", importPkg, i)
		}
		c.ImportedFiles[alias] = importRelPath
		c.ImportedSymbols[importRelPath] = alias
		c.d.Import(importRelPath, importPkg, alias)
		c.j.Import(importRelPath, importPkg, alias)
	}

	parts := strings.Split(name, ".")
	parts[1] = alias
	resolved := strings.Join(parts[1:], ".")
	return resolved
}

func (c *Codegen) typeAnnotation(f *descriptorpb.FieldDescriptorProto) string {
	if c.isMapField(f) {
		entryType := c.Index.MessageTypes[f.GetTypeName()]
		kf := entryType.GetField()[0]
		vf := entryType.GetField()[1]
		return fmt.Sprintf("Record<%s, %s>", c.presentSingularTypeAnnotation(kf), c.presentSingularTypeAnnotation(vf))
	}
	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		return fmt.Sprintf("Array<%s>", c.presentSingularTypeAnnotation(f))
	}

	return c.singularTypeAnnotation(f)
}

func (c *Codegen) singularTypeAnnotation(f *descriptorpb.FieldDescriptorProto) string {
	a := c.presentSingularTypeAnnotation(f)
	if f.GetProto3Optional() {
		a += " | null | undefined /* optional */"
	} else if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		a += " | null | undefined"
	}
	return a
}

func (c *Codegen) presentSingularTypeAnnotation(f *descriptorpb.FieldDescriptorProto) string {
	if isLong(f.GetType()) {
		c.d.DefaultImport("long", "Long")
		c.j.DefaultImport("long", "Long")
		return "Long"
	}
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32:
		return "number"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "Uint8Array"
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		return c.resolveTypeName(f.GetTypeName(), "")
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		// TODO: support --noforce-message to allow interface types here?
		return c.resolveTypeName(f.GetTypeName(), "")
	default:
		typeName := f.GetTypeName()
		if typeName == "" {
			name := descriptorpb.FieldDescriptorProto_Type_name[int32(f.GetType())]
			typeName = strings.ToLower(strings.TrimPrefix(name, "TYPE_"))
		}
		fatalf("unsupported type %q for field %q", typeName, f.GetName())
		return "" // unreachable
	}
}

func (c *Codegen) isMapField(f *descriptorpb.FieldDescriptorProto) bool {
	return c.Index.MessageTypes[f.GetTypeName()].GetOptions().GetMapEntry()
}

func (c *Codegen) defaultValueExpression(f *descriptorpb.FieldDescriptorProto) string {
	// TODO: Respect [default] annotation

	// Map fields default to empty object
	if c.isMapField(f) {
		return "$util.emptyObject"
	}
	// Repeated fields (except for repeated MapEntry fields) default to empty
	// array
	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		return "$util.emptyArray"
	}

	if f.GetProto3Optional() {
		return "null"
	}

	t := f.GetType()
	if isLong(t) {
		return fmt.Sprintf("$util.Long ? $util.Long.fromBits(0, 0, %t) : 0", isUint(t))
	}
	switch t {
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32:
		return "0"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "false"
	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "new Uint8Array()"
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return `""`
	case descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		return "0"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		return "null"
	default:
		return "undefined"
	}
}

func (c *Codegen) generateFromObjectConversionStatements(dest, src string, f *descriptorpb.FieldDescriptorProto, messageType *descriptorpb.DescriptorProto, ns string) {
	j := c.j
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
		j.Lf("switch (%s) {", src)
		et := c.Index.EnumTypes[f.GetTypeName()]
		for _, v := range et.GetValue() {
			j.Lf(`case "%s":`, v.GetName())
			j.Lf("case %d: {", v.GetNumber())
			j.Lf("%s = %d;", dest, v.GetNumber())
			j.Lf("break;")
			j.Lf("}")
		}

		j.Lf("default: {")
		j.Lf(`if (typeof %s == "number") {`, src)
		j.Lf("%s = %s;", dest, src)
		j.Lf("break;")
		j.Lf("}")
		// Fallback to default value (0) for repeated fields
		// to avoid leaving holes
		if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
			j.Lf("%s = 0;", dest)
		}
		j.Lf("break;")
		j.Lf("}") // end case default

		j.Lf("}") // end switch
		return
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		j.Lf(`if (typeof %s !== "object") {`, src)
		// TODO: include full field path in error here
		j.Lf(`throw new TypeError(".%s.%s.%s: object expected, but got " + (typeof %s));`, ns, messageType.GetName(), f.GetJsonName(), src)
		j.Lf("}")
		j.Lf("%s = %s.fromObject(%s);", dest, c.resolveTypeName(f.GetTypeName(), "$root."), src)
		return
	}
	if isFloatingPoint(f.GetType()) {
		j.Lf("%s = Number(%s);", dest, src)
		return
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_UINT32 ||
		f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_FIXED32 {
		j.Lf("%s = %s >>> 0;", dest, src)
		return
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_INT32 ||
		f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_SINT32 ||
		f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_SFIXED32 {
		j.Lf("%s = %s | 0;", dest, src)
		return
	}
	if isLong(f.GetType()) {
		j.Lf("if ($util.Long) {")
		j.Lf("(%s = $util.Long.fromValue(%s)).unsigned = %t;", dest, src, isUint(f.GetType()))
		j.Lf(`} else if (typeof %s === "string") {`, src)
		j.Lf(`%s = parseInt(%s, 10);`, dest, src)
		j.Lf(`} else if (typeof %s === "number") {`, src)
		j.Lf(`%s = %s;`, dest, src)
		j.Lf(`} else if (typeof %s === "object") {`, src)
		toNumberArg := ""
		if isUint(f.GetType()) {
			toNumberArg = "true"
		}
		j.Lf(`%s = new $util.LongBits(%s.low >>> 0, %s.high >>> 0).toNumber(%s);`, dest, src, src, toNumberArg)
		j.Lf("}")
		return
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_BYTES {
		j.Lf(`if (typeof %s === "string") {`, src)
		j.Lf(`$util.base64.decode(%s, %s = $util.newBuffer($util.base64.length(%s)), 0);`, src, dest, src)
		j.Lf("} else if (%s.length >= 0) {", src)
		j.Lf("%s = %s;", dest, src)
		j.Lf("}")
		return
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_STRING {
		j.Lf("%s = String(%s);", dest, src)
		return
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_BOOL {
		j.Lf("%s = Boolean(%s);", dest, src)
	}
}

func (c *Codegen) toObjectConversionExpression(f *descriptorpb.FieldDescriptorProto, expr string, args ...any) string {
	expr = fmt.Sprintf(expr, args...)
	if isLong(f.GetType()) {
		toNumberArg := ""
		if isUint(f.GetType()) {
			toNumberArg = "true"
		}
		return fmt.Sprintf(
			`typeof %s === "number" ? (options.longs === String ? String(%s) : %s) : (options.longs === String ? $util.Long.prototype.toString.call(%s) : options.longs === Number ? new $util.LongBits(%s.low >>> 0, %s.high >>> 0).toNumber(%s) : %s)`,
			expr, expr, expr, expr, expr, expr, toNumberArg, expr)
	}
	if isFloatingPoint(f.GetType()) {
		return fmt.Sprintf(
			"options.json && !isFinite(%s) ? String(%s) : %s",
			expr, expr, expr)
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_BYTES {
		return fmt.Sprintf(
			"options.bytes === String ? $util.base64.encode(%s, 0, %s.length) : options.bytes === Array ? Array.prototype.slice.call(%s) : %s",
			expr, expr, expr, expr)
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
		return fmt.Sprintf(
			"%s.toObject(%s, options)",
			c.resolveTypeName(f.GetTypeName(), "$root."), expr)
	}
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
		return fmt.Sprintf(
			"options.enums === String ? %s[%s] === undefined ? %s : %s[%s] : %s",
			c.resolveTypeName(f.GetTypeName(), "$root."), expr, expr, c.resolveTypeName(f.GetTypeName(), "$root."), expr, expr,
		)
	}
	return expr
}

func (c *Codegen) enumZeroValue(f *descriptorpb.FieldDescriptorProto) *descriptorpb.EnumValueDescriptorProto {
	enumType := c.Index.EnumTypes[f.GetTypeName()]
	for _, v := range enumType.GetValue() {
		if v.GetNumber() == 0 {
			return v
		}
	}
	return nil
}

// Returns the protobufjs reader/writer method corresponding to the given field
// type.
func encodeMethodName(f *descriptorpb.FieldDescriptorProto) string {
	if f.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
		return "int32"
	}
	name := descriptorpb.FieldDescriptorProto_Type_name[int32(f.GetType())]
	return strings.ToLower(strings.TrimPrefix(name, "TYPE_"))
}

func oneofFieldName(decl *descriptorpb.OneofDescriptorProto) string {
	parts := strings.Split(decl.GetName(), "_")
	if len(parts) == 0 {
		return ""
	}
	out := parts[0]
	for _, p := range parts[1:] {
		if out == "" {
			out += "_" + p
			continue
		}
		if len(p) == 0 {
			continue
		}
		out += strings.ToUpper(p[:1]) + p[1:]
	}
	return out
}

func serviceMethodJSName(method *descriptorpb.MethodDescriptorProto) string {
	return strings.ToLower(method.GetName()[:1]) + method.GetName()[1:]
}

func interfaceTypeName(typeName string) string {
	typeName = strings.TrimPrefix(typeName, ".")
	parts := strings.Split(typeName, ".")
	parts[len(parts)-1] = "I" + parts[len(parts)-1]
	return strings.Join(parts, ".")
}
